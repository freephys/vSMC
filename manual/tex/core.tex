\chapter{Core concepts}
\label{chap:Core concepts}

In this chapter, we introduce the core concepts of the library. There are five
of them. At the center is a class that represent the state space, that is the
value of the states $\{X_t^i\}_{i=1}^{N_t}$. This class may also contain other
members that is specific for the model, such as the data. Next is the weights
$\{W_t^i\}_{i=1}^{N_t}$. Together with the states, they form a particle system.
A sampler operates on a particle system to produce samples iteratively. A
sampler might also use some monitors to calculate estimates,
$\varphi(\{X_t^i,W_t^i\}_{i=1}^{N_t})$ as it progresses. These concepts are all
abstracted in the library. Now we introduce each of them. For brevity, we will
drop the time dependent subscript $t$ in the remaining of this chapter.

\section{State}
\label{sec:State}

Let $E$ be the state space, a state object, say \verb|T|, shall be able to
represent the states collection $\{X^i\}_{i=1}^N$ and everything it depends on.
Let $d\ge1$ such that $E\subseteq\calX^d$ for some space $\calX$. Then, we can
represent the states as in an $N$ by $d$ matrix. In this situation, the library
provides a default implementation,
\begin{Verbatim}
  template <MatrixLayout Layout, std::size_t Dim, typename T>
  class StateMatrix;
\end{Verbatim}
where \verb|Layout| is either \verb|RowMajor| or \verb|ColMajor|, which
specifies the matrix layout, \verb|Dim| is the dimension of $X^i$, i.e., $d$
and \verb|T| shall be a \cpp type that represents values in $\calX$. For
example, if $E\subseteq\Real^d$, then one can use the following class,
\begin{Verbatim}
  StateMatrix<RowMajor, d, double> state(N);
\end{Verbatim}
We shall note that, this is not a general purpose matrix class for use such as
linear algebra. It is more of a container with a few additional methods. Below
is some common operations can be done on \verb|state|,
\begin{Verbatim}
  state.size();          // Get the sample size
  state.dim();           // Get the dimension
  state.resize(N);       // Set a new sample size
  state.reserve(N);      // Reserve space for a new sample size
  state.shrink_to_fit(); // Release memory no longer needed
  state(i, j);           // The element at row i, column j
\end{Verbatim}
If the template parameter \verb|Dim| is equal to zero, then it is assumed that
the dimension is dynamic and may change later. In this case, there are
additional methods,
\begin{Verbatim}
  StateMatrix<RowMajor, Dynamic, double> state(N, d);
  state.resize(N, d);  // Set new sample size and dimension
  state.resize_dim(d); // Set a new dimension without chaning the sample size
  state.reserve(N, d); // Reserve space for new sample size and dimension
\end{Verbatim}
The enumerator \verb|Dynamic| above has the value zero. Note that, these
methods are only available when the template parameter \verb|Dim| is zero.
Attempting to call these methods when it is positive will result in
compile-time errors.

There are two more methods, whose purpose will become clear later. The first
is,
\begin{Verbatim}
  void duplicate(size_type src, size_type dst);
\end{Verbatim}
Let the value of \verb|src| and \verb|dst| be $i$ and $j$, respectively. This
method set the value of $X^j$ to that of $X^i$. In other words, $X^i$ is
duplicated while $X^j$ is eliminated. The other method is,
\begin{Verbatim}
  template <typename IntType, typename InputIter>
  void select(IntType N, InputIter index);
\end{Verbatim}
where \verb|index| is an $N$-vector, say $\{a_i\}_{i=1}^N$. This method select
samples to form a new collection $\{\hat{X}^i\}_{i=1}^N$ such that $\hat{X}^i =
X^{a_i}$. Note that, the sample size $N$ does not have to be the same as the
original. This is closely related to the selection step of \smc algorithms.

It is also possible to get pointers to the raw data,
\begin{Verbatim}
  state.data(); // Equivalent to &state(0, 0)
\end{Verbatim}
If \verb|Layout| is \verb|RowMajor|, then one can get pointers to the beginning
of each $X^i$,
\begin{Verbatim}
  state.row_data(i); // Equivalent to &state(i, 0)
\end{Verbatim}
If \verb|Layout| is \verb|ColMajor|, then one can get pointers to the beginning
of each dimension of $X^i$,
\begin{Verbatim}
  state.col_data(j); // Equivalent to &state(0, j)
\end{Verbatim}
They are necessary for easy interfacing with many numerical libraries, but the
user shall be careful when using them.

\section{Weight}
\label{sec:Weight}

The weights $\{W^i\}_{i=1}^N$ is abstracted by the class \verb|Weight|. For
example,
\begin{Verbatim}
  Weight w(N);
  w.size();          // Get the sample size
  w.resize(N);       // Set a new sample size
  w.reserve(N);      // Reserve space for a new sample size
  w.shrink_to_fit(); // Release memory no longer needed.
  w.data();          // Get a pointer to the beginning of the weight
\end{Verbatim}
One property of \verb|Weight| is that, $\{W^i\}_{i=1}$ is always normalized.
For example, after the construction or resizing, the weights are set to equal,
i.e., $W^i = 1 / N$, for $i = 1,\dots,N$. One can manually set the weights to
equal by
\begin{Verbatim}
  w.set_equal();
\end{Verbatim}
The weights can be manipulated in variance way. Let $v$ be an iterator
pointing to an $N$-vector $\{v^i\}_{i=1}^N$. To set $W_i \propto v_i$,
\begin{Verbatim}
  w.set(v);
\end{Verbatim}
To set $\log W^i = v^i + \mathrm{const.}$, call
\begin{Verbatim}
  w.set_log(v);
\end{Verbatim}
To set weights incrementally, call
\begin{Verbatim}
  w.mul(v);
  w.add_log(v);
\end{Verbatim}
which sets $W^i \propto W^i v^i$ and $\log W^i = \log W^i + v^i +
\mathrm{const.}$, respectively. The value of \ess of the weights can be
obtained by,
\begin{Verbatim}
  w.ess();
\end{Verbatim}
One may also draw an integer $1 \le k \le N$ according to the weights by
calling,
\begin{Verbatim}
  w.draw(rng);
\end{Verbatim}
where \verb|rng| is a \cppoo{} \rng engine object. Last, one can obtain a
pointer to the raw data,
\begin{Verbatim}
  w.data();
\end{Verbatim}
Again, this shall be used with care. Unlike \verb|StateMatrix|, the member
\verb|data| always returns a pointer of type \verb|double|. In other words, the
\verb|Weight| does not provide any means for user to change an individual $W^i$
without changing the others. Conceptually, it is the relative weights that
matter. And changing one of them is in fact changing $\{W^i\}_{i=1}^N$ as a
whole.

\section{Particle}
\label{sec:Particle}

A particle system, abstracted by the class template,
\begin{Verbatim}
  template <typename T>
  class Particle;
\end{Verbatim}
is essentially formed by three parts. The first is an object of type \verb|T|,
that abstract the states $\{X^i\}_{i=1}^N$. The second is a type \verb|Weight|
object that abstracts the weights $\{W^i\}_{i=1}^N$. And the third is a
collection of \cppoo{} \rng engines. There are some restrictions on the type
\verb|T|. The constructor of \verb|Particle| is as the following,
\begin{Verbatim}
  template <typename... Args>
  explicit Particle(size_type N, Args &&... args)
\end{Verbatim}
where the first argument is the sample size. This and all other arguments, are
passed down to the constructor of type \verb|T|. For example,
\begin{Verbatim}
  using T = StateMatrix<RowMajor, Dynamic, double>;
  Particle particle(N, d);
\end{Verbatim}
will construct the \verb|StateMatrix| object with \verb|N| and \verb|d|
arguments. Therefore, \verb|T| mush has an constructor that accepts an integer
value as its first argument. The possible arguments of the constructor of
\verb|Particle| is thus the same as those of \verb|T|. Second, \verb|T| has to
provide a \verb|select| method similar to that of \verb|StateMatrix|. The
library does not really impose any restriction on the internal structure of
\verb|T|. And thus it cannot perform the selection by itself. However, for more
complicated case, one can always define a class, say \verb|StateType| to
represent the space $E$, and use a one dimension \verb|StateMatrix| as the type
\verb|T|. For example,
\begin{Verbatim}
  class StateType; // User defined type
  using T = StateMatrix<RowMajor, 1, StateType>;
  Particle<T> particle(N);
\end{Verbatim}
More usefully, one can create a new type by deriving from \verb|StateMatrix|.
Note that, though the \verb|select| method of \verb|StateMatrix| is written as
a function template that can accept any integers and iterators as its argument,
for a user defined type \verb|T| only need to support the following signature,
\begin{Verbatim}
  ReturnType select(size_type N, const size_type *index);
\end{Verbatim}
where \verb|size_type| is \verb|T::size_type| if \verb|T| has such a member
type, and \verb|std::size_t| otherwise.

The \verb|Weight| type object is constructed with a single argument, $N$. To
retrieve references to the type \verb|T| and \verb|Weight| objects, one can
call,
\begin{Verbatim}
  particle.state();
  particle.weight();
\end{Verbatim}
respectively. Last but not least, the \verb|Particle| class also contains a
collection of \rng engines. The method,
\begin{Verbatim}
  particle.rng(i);
\end{Verbatim}
returns a reference to an \rng engine, specific to the $i$\ith particle. For $i
\ne j$, if the following,
\begin{Verbatim}
  auto &rng1 = particle.rng(i);
  auto &rng2 = particle.rng(j);
\end{Verbatim}
are called from two different threads, then \verb|rng1| and \verb|rng2| will be
instances of two independent \rng engines. The details are in
section~\ref{sec:Multiple RNG streams}. The \verb|Particle| class also contains
an \rng engine independent of any particles,
\begin{Verbatim}
  auto &rng = particle.rng();
\end{Verbatim}
We will revisit this topic later when we discuss multi-threaded implementations
in the next chapter.

\subsection{Resize the particle system}
\label{sub:Resize the particle system}

The sample size of can be obtained by,
\begin{Verbatim}
  particle.size();
\end{Verbatim}
and it can also be changed. However, in Monte Carlo algorithms, one does not
change the sample size without arbitrarily. Which sample to preserve and
possibly duplicated and which sample to be eliminated, has to be done according
to some algorithms that produce desirable effects. There are a few methods to
resize a particle system. There share two common properties. They take the new
sample size, say $N$, as their first argument. The other is that in the end,
the call the \verb|select| method on the type \verb|T| object, with $N$ and an
iterator, say \verb|index|, that points to a $N$-vector $\{a_i\}_{i=1}^N$ as
arguments. In addition they all call the \verb|resize| method on the type
\verb|Weight| object with $N$ as the argument. How the type \verb|T| handles
the call to the \verb|select| method is up to the user. But usually it should
behave similarly to that of \verb|StateMatrix|. Below is descriptions of each
method for resizing a particle system. They differ in how they generate the
index vector $\{a_i\}_{i=1}^N$. We will let $M$ denote the original sample
size. Also, for clarity, in the mathematical description of the vectors, we are
using indices starting with $1$, while in the actual \cpp program, the indices
starts with zero, as usual.

\subsubsection{Resize with given index vectors}

\begin{Verbatim}
  template <typename InputIter>
  void resize_by_index(size_type N, InputIter index);
\end{Verbatim}
This method take the index vector as its input and pass it directly to the
\verb|select| method of \verb|T|. If \verb|Index| is not convertible to a
pointer of type \verb|size_type|, then the index vector will be first copied to
a temporary and a pointer to it will be passed. Recall that, \verb|T| is not
required to handle all types of iterators.

\subsubsection{Resize with resampling algorithms}

\begin{Verbatim}
  template <typename ResampleType>
  void resize_by_resample(size_type N, ResampleType &&op)
\end{Verbatim}
This method generate the index vector according to a resampling algorithm. A
resampling algorithm produce the number of replications of each particle in the
original system. The function \verb|op| shall accept a call as the following,
\begin{Verbatim}
  op(M, N, rng, w, rep);
\end{Verbatim}
where $M$ and $N$ are the original and new sample size, \verb|rng| is a
reference to an \rng engine, \verb|w| is a pointer of type \verb|double|, that
points to the $M$-vector of normalized weights. And last, \verb|r| is a pointer
of type \verb|size_type| that points to a $M$-vector of the number of
duplicates of each particles, say $\{r_i\}_{i=1}^M$. It is required that, the
results shall satisfy $r_i\ge0$ for $i=1,\dots,M$ and $\sum_{i=1}^M r_i = N$.
The index vector is generated such that,
\begin{align*}
  a_i &= i &&\text{if } r_i > 0, \text{ for } i = 1,\dots,\min\{M, N\} \\
  \sum_{i=1}^N\bbI_{\{j\}}(a_i) &= r_j &&\text{for } j = 1,\dots,M
\end{align*}

\subsubsection{Resize with uniform selection}

\begin{Verbatim}
  void resize_by_uniform(size_type N);
\end{Verbatim}
The index vector is generated such that, $\Prob(a_i = j) = 1/M$, for $i =
1,\dots,N$, $j = 1,\dots,M$. This is equivalent to multinomial resampling with
equal weights.

\subsection{Clone the particle system}
\label{sub:Clone the particle system}

The \verb|Particle<T>| class has the usual special members, such as the copy
constructor, assignment operator, etc. They work just as usual. For example,
\begin{Verbatim}
  auto new_particle = particle;
\end{Verbatim}
create a new particle system as an exact duplicate of the original. However,
this ``exactness'' is often undesired. The duplicated particle system will have
exactly the same states of \rng engines as the original. And therefore, any
random samples generated from this new system, will be exactly the same as the
original. This is hardly the desired effects in algorithms where duplicating a
particle system into multiple copies is required. In this situation, one can
use the \verb|clone| method,
\begin{Verbatim}
  auto new_particle = particle.clone();
\end{Verbatim}
In contrast to the copy constructor, this will create a new particle system
exactly the same as the original, except that all \rng engines within the new
system is re-seeded.

\section{Sampler}
\label{sec:Sampler}

A sampler is formed by the particle system together with all the operations on
it. It is abstracted by the class template,
\begin{Verbatim}
  template <typename T>
  class Sampler;
\end{Verbatim}
The template parameter \verb|T| is same as that of \verb|Particle|. Its
constructor takes arbitrary arguments,
\begin{Verbatim}
  template <typename... Args>
  explicit Sampler(Args &&... args)
\end{Verbatim}
and all arguments are passed down to the constructor of \verb|Particle|. For
example,
\begin{Verbatim}
  using T = StateMatrix<RowMajor, Dynamic, double>;
  Sampler<T> sampler(N, d);
\end{Verbatim}

There two main types of methods for this class. The first is to configure a
sampler by adding operations on the particles systems to it. And the second is
iterating the sampler. Any callable objects that is convertible to the
following can be used as operations on the particle system.
\begin{Verbatim}
  using eval_type = std::function<std::size_t(std::size_t, Particle<T> &)>;
\end{Verbatim}
For example,
\begin{Verbatim}
  std::size_t eval(std::size_t iter, Particle<T> &particle);
\end{Verbatim}
Such a function can be attached to the sampler by the \verb|eval| method,
\begin{Verbatim}
  Sampler<T> &eval(
      const eval_type &new_eval, SamplerStage stage, bool append = true);
\end{Verbatim}
For example,
\begin{Verbatim}
  sampler.eval(eval, SamplerInit | SamplerMove, true);
\end{Verbatim}
The first argument is the evaluation object. The sampler maintains a sequence
of evaluation steps. If the third argument is true, then the new evaluation
object will be appended to the existing sequence. Otherwise, the sequence will
be cleared first. The second argument will be explained shortly. The sampler
can also have an optional resampling step. This can be attached to the sampler
by the following method,
\begin{Verbatim}
  Sampler<T> &resample_method(
      ResampleScheme scheme, double threshold = resample_threshold_always());
\end{Verbatim}
which uses a builtin resampling scheme of the library (see
section~\ref{sec:Builtin algorithms}). Or alternatively,
\begin{Verbatim}
  Sampler<T> &resample_method(const eval_type &res_eval,
      double threshold = resample_threshold_always());
\end{Verbatim}
In either case, the parameter \verb|threshold| specifies the condition under
which the resampling step will be actually performed. Let its value be
$\alpha$, resampling is performed if and only if $\ess < \alpha N$.

\subsection{Evaluation stages}
\label{sub:Evaluation stages}

The sampler is iterated with two methods,
\begin{Verbatim}
  sampler.initialize();
  sampler.iterate(n);
\end{Verbatim}
The first initialize the sampler, and the second iterate the sampler $n$ times.
In each case, the sequence of user defined evaluation objects will be called,
such as the \verb|eval| function defined earlier. The first argument passed to
it is the iteration number. This number is reset to zero when \verb|initialize|
is called and incremented by one each time the sampler is iterated. The
initialization is divided into the following stages,
\begin{description}
  \item[\texttt{SamplerInit}] Initialize the particle system
    $\{X_0^i,W_0^i\}_{i=1}^{N_0}$.
  \item[Resampling] If $\ess < \alpha N$, resampling the particle system to
    $\{\hat{X}_0^i,\hat{W}_0^i\}_{i=1}^{\hat{N}_0}$.
  \item[\texttt{SamplerMCMC}] Mutate the particle system to
    $\{\check{X}_0^i,\check{W}_0^i\}_{i=1}^{\check{N}_0}$.
\end{description}
and the iteration at step $t$, is divided into the following stages,
\begin{description}
  \item[\texttt{SamplerMove}] Move the particle system from
    $\{\check{X}_{t-1},\check{W}_{t-1}\}_{i=1}^{\check{N}_{t-1}}$ to
    $\{X_t^i,W_t^i\}_{i=1}^{N_t}$.
  \item[Resampling] If $\ess < \alpha N$, resampling the particle system to
    $\{\hat{X}_t^i,\hat{W}_t^i\}_{i=1}^{\hat{N}_t}$.
  \item[\texttt{SamplerMCMC}] Mutate the particle system to
    $\{\check{X}_t^i,\check{W}_t^i\}_{\check{N}_t}$.
\end{description}
In each of these stages, one or more \verb|eval_type| objects are called upon
to perform the necessary sampling and calculation. In the \emph{Resampling}
stage, the evaluation object set by \verb|resmaple_method| will be used to used
to perform the resampling. The builtin algorithms will use the \verb|select|
method of the state type \verb|T| to perform the selection after generating the
index vector. In all other three types of stages, all objects in the sequence
of evaluations objects set by the \verb|eval| method of \verb|Sampler| is
checked. Recall that, the each evaluation object is attached to the sampler by
a call to the following method,
\begin{Verbatim}
  Sampler<T> &eval(
      const eval_type &new_eval, SamplerStage stage, bool append = true);
\end{Verbatim}
At each stage, the value of the second parameter will be check. For example,
at the \verb|SamplerInit| stage, this object will be called if and only if the
value of \verb|SamplerInit & stage| is non-zero. The other two stages,
\verb|SamplerMove| and \verb|SamplerMCMC| is similar. The last one is so named
because in many algorithms, the mutation step is performed by some \mcmc
kernel. It is not universally so. Clearly, the evaluation objects at that
stage, if any, do not have to perform \mcmc type mutations.

\section{Monitor}
\label{sec:Monitor}

Let $\varphi_t(\{X_t^i,W_t^i\}_{i=1}^{N_t})$ be some test function with values
in $\Real^d$. It is often of interest to monitor its value as the algorithm
progresses. In the library, this is done through the class \verb|Monitor<T>|.
It has the following constructor,
\begin{Verbatim}
  Monitor(std::size_t dim, const eval_type &eval, bool record_only = false,
      MonitorStage stage = MonitorMCMC);
\end{Verbatim}
The first parameter \verb|dim| is the dimension of $\varphi_t$, $d$. The second
is a user defined callback function. More specifically,
\begin{Verbatim}
  using eval_type =
      std::function<void(std::size_t, std::size_t, Particle<T> &, double *)>;
\end{Verbatim}
For example,
\begin{Verbatim}
  void varphi(std::size_t t, std::size_t d, Particle<T> &particle, double *r);
\end{Verbatim}
When this function is called. The first argument passed to it is $t$, the
iteration number. The second is $d$, the dimension. The third is a reference to
the particle system at iteration $t$. And the last is a pointer to a vector for
output.

The third parameter of the constructor of \verb|Monitor|, \verb|record_only|
determines how shall the function above behave. If it is true, then the
function \verb|varphi| shall return the value of $\varphi_t$ directly, and the
output parameter \verb|r| points to a $d$-vector.  In this case, \verb|Monitor|
merely record the values of $\varphi_t$ at each iteration. On the other hand,
if \verb|record_only| is false, then it is assumed that $\varphi_t$ takes the
following form,
\begin{equation*}
  \varphi_t(\{X_t^i,W_t^i\}_{i=1}^{N_t}) =
  \sum_{i=1}^{N_t} W_t^i \varphi_t^i(X_t^i).
\end{equation*}
And the output parameter \verb|r| is an $N$ by $d$ row major matrix, with the
$d$-vector value $\varphi_t^i(X_t^i)$ written into each row of this matrix. And
each time \verb|varphi| is called, \verb|Monitor| will compute and store the
result of the summation above.

The last parameter of the constructor of \verb|Monitor| specifies when shall
the calculation of $\varphi_t$ be carried out. Possible values are,
\begin{description}
  \item[\texttt{MonitorMove}] The evaluation happens after the
    \verb|SamplerInit| or \verb|SamplerMove| stage, i.e., right before the
    possible resampling.
  \item[\texttt{MonitorResample}] The evaluation happens right after the
    \emph{Resampling} stage.
  \item[\texttt{MonitorMCMC}] The evaluation happens after the
    \verb|SamplerMCMC| stage, i.e., at the end of the initialization or
    iteration.
\end{description}

A monitor can be attached to a sampler. For example,
\begin{Verbatim}
  Monitor<T> mon(d, eval, false, MonitorMCMC);
  sampler.monitor("name", mon);
\end{Verbatim}
Later, this monitor can be retrieved by,
\begin{Verbatim}
  const auto &mon = sampler.monitor("name");
\end{Verbatim}
One can also detach the monitor from the sampler by,
\begin{Verbatim}
  sampler.monitor_clear("name");
\end{Verbatim}
One can retrieve the results in various ways. Every time a monitor being
evaluated, it record two values. The first is the iteration number $t$, at
which it was evaluated. The other is the value of $\varphi_t$. One can retrieve
these values using the following methods,
\begin{Verbatim}
  mon.iter_size();  // Total number of evaluations
  mon.index(j);     // The iteration number of the j-th evaluation
  mon.record(i, j); // The value of the i-th component of the result
                    // at the j-th evaluation
\end{Verbatim}
Note that, the monitor does not have to be attached to a sampler before it
starting initialization. It can also be detached before the sampler finishing
all iterations. Therefore, the iteration numbers of a monitor being evaluated
are not necessarily the sequence $0,1,\dots,n$, where $n$ is the total number
of iterations.

\section{Example}
\label{sec:Example (Core concepts)}
