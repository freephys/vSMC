\chapter{Random number generating}
\label{chap:Random number generating}

The library has a comprehensive \rng system to facilitate implementation of
Monte Carlo algorithms. A set of counter-based \rng{}s developed in
\textcite{Salmon:2011um} are re-implemented in the library with some
extensions. In addition wrappers for high performance \rng{}s in \mkl are also
provided, such that they can be used as \cppoo \rng engines. Some continuous
distributions, including all those in the standard library, are implemented.
Some of them are considerably faster than their standard library counter-parts.

Section~\ref{sec:Vectorized random number generating} introduces the library's
interface for vectorized random number generating.
Section~\ref{sec:Counter-based RNG} details the counter-based \rng{}s
implemented in the library. Section~\ref{sec:Non-deterministic RNG} briefly
discuss the non-deterministic \rng{}s using \rdrand instructions and
section~\ref{sec:MKL RNG} shows how to use \rng{}s in the \mkl library as
\cppoo engines. Section~\ref{sec:Distributions} discusses the distributions
implemented by this library. Section~\ref{sec:Seeding} discusses how to seed
counter-based \rng{}s.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

Before we discuss other features, we first introduce a generic function
\verb|rng_rand|, which provides vectorized random number generating.
\begin{cppcode}
  template <typename RNGType>
  inline void rng_rand(
      RNGType &rng, std::size_t n, typename RNGType::result_type *r);

  template <typename RNGType, typename DistributionType>
  inline void rng_rand(RNGType &rng, const DistributionType &distribution,
      std::size_t n, typename DistributionType::result_type *r);
\end{cppcode}
The first is equivalent to generating random integers through a loop. For
example,
\begin{cppcode}
  Vector<RNGType::result_type> r1(n);
  Vector<RNGType::result_type> r2(n);
  RNGType rng1;
  RNGType rng2;

  for (std::size_t i = 0; i != n; ++i)
      r1[i] = rng1();

  rng_rand(rng2, n, r2.data());

  r1 == r2; // always true
\end{cppcode}
The second version of \verb|rng_rand| is similar to the loop,
\begin{cppcode}
  for (std::size_t i = 0; i != n; ++i)
      r[i] = distribution(rng);
\end{cppcode}
However, the results will not always be exactly the same, though the vectorized
version will generate random numbers with the same distributions as expected.

The advantage of using \verb|rng_rand| is that, if \verb|RNGType| or
\verb|DistributionType| are classes defined by this library, then vectorized
implementations might be used instead of using the loop. For some
distributions, the performance gain can be significant. Consider the following
dummy example,
\begin{cppcode}
  std::size_t n = 10000;
  RNG rng_vsmc;
  MKL_MT19937 rng_mkl;
  std::normal_distribution<double> rnorm_std;
  NormalDistribution<double> rnorm_vsmc;
  Vector<double> r(n);

  // Method 1
  for (std::size_t i = 0; i != n; ++i)
      r[i] = rnorm_std(rng_vsmc);

  // Method 2
  for (std::size_t i = 0; i != n; ++i)
      r[i] = rnorm_vsmc(rng_vsmc);

  // Method 3
  rng_rand(rng_vsmc, rnorm_vsmc, n, r.data());

  // Method 4
  rng_rand(rng_mkl, rnorm_vsmc, n, r.data());
\end{cppcode}
On the author's computer, on average method 1 costs 68 nanoseconds to generate
one standard Normal random number. Method 2 costs 52 nanoseconds while method 3
costs only 11 nanoseconds. The last, when the \rng{} engine is an \mkl{} \rng
wrapper, the \mkl library's routines are used and it costs only 8 nanoseconds
per element. Normal distribution is relatively simple. For other distributions,
such as the Gamma distribution, the difference can be even more dramatic. And
the library even beats \mkl in performance for some distributions.

\section{Counter-based RNG}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng engines. Unfortunately, none of
them are suitable for parallel computing without considerable efforts. The
development by \textcite{Salmon:2011um} made high performance parallel \rng
much more accessible. The \rng{}s introduced in the paper use deterministic
functions $f_k$, such that, for a sequence $\{c_i = i\}_{i\ge0}$, the sequence
$\{y_i\}_{i\ge0}$, $y_i = f_k(c_i)$, appears as random. In addition, for $k_1
\ne k_2$, $f_{k_1}$ and $f_{k_2}$ will generate two sequences that appear
statistically independent. Compared to more conventional \rng{}s which use
recursions $y_i = f_k(y_{i - 1})$, these counter-based \rng{}s are much easier
to setup in a parallelized environment.

If $c$, the counter, is an unsigned integer with $b$ bits, and $k$, the key, is
an unsigned integer with $d$ bits. Then for each $k$, the \rng has a period
$2^b$. And there can be at most $2^d$ independent streams.
Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in this library, along with the bits of the counter and the key. They all
conform to the \cppoo uniform \rng concept and output 32-bits integers. For
64-bits integer output, a suffix \verb|_64| may be appended to corresponding
\rng engine names. For example, \verb|Threefry4x64| and \verb|Threefry4x64_64|
generate the same 256-bits random integers internally. The only difference is
that \verb|operator()| of the former returns 32-bits integers while the later
returns 64-bits integers.

\begin{table}
  \begin{tabularx}{\textwidth}{lXX}
    \toprule
    Class & Counter bits & Key bits \\
    \midrule
    \verb|AES128x1|, \verb|ARS128x2|, \verb|AES128x4|, \verb|AES128x8|
    & $128$  & $128$  \\
    \verb|AES192x1|, \verb|ARS192x2|, \verb|AES192x4|, \verb|AES192x8|
    & $128$  & $192$  \\
    \verb|AES256x1|, \verb|ARS256x2|, \verb|AES256x4|, \verb|AES256x8|
    & $128$  & $256$  \\
    \verb|ARSx1|, \verb|ARS256x2|, \verb|ARSx4|, \verb|ARSx8|
    & $128$  & $128$  \\
    \verb|Philox2x32|    & $64$   & $32$   \\
    \verb|Philox2x64|    & $128$  & $64$   \\
    \verb|Philox4x32|    & $128$  & $64$   \\
    \verb|Philox4x64|    & $256$  & $128$  \\
    \verb|Threefry2x32|  & $64$   & $64$   \\
    \verb|Threefry2x64|  & $128$  & $128$  \\
    \verb|Threefry4x32|  & $128$  & $128$  \\
    \verb|Threefry4x64|  & $256$  & $256$  \\
    \verb|Threefry8x64|  & $512$  & $512$  \\
    \verb|Threefry16x64| & $1024$ & $1024$ \\
    \bottomrule
  \end{tabularx}
  \caption{Counter-based \rng; Each \rng engine may have suffix \texttt{\_64}}
  \label{tab:Counter-based RNG}
\end{table}

All \rng{}s in table~\ref{tab:Counter-based RNG} are actually type aliases.
More generally the library defines the following class template as the
interface,
\begin{cppcode}
  template <typename ResultType, typename Generator>
  class CounterEngine;
\end{cppcode}
where \verb|ResultType| shall be an unsigned integer type and \verb|Generator|
is the class that actually implement the algorithm. It has at least two member
types, \verb|ctr_type| and \verb|key_type|, the types of the counter and key.
In addition, four methods are required,
\begin{cppcode}
  // The size of output in bytes
  static constexpr std::size_t size();

  // Reset the key of the generator
  void reset(const key_type &key);

  // Increment counter and generate a new random buffer
  template <typename ResultType>
  void operator()(ctr_type &ctr,
      std::array<ResultType, size() / sizeof(ResultType)> &buffer);

  // Increment counter and generate n new random buffers
  template <typename ResultType>
  void operator()(ctr_type &ctr, std::size_t n,
      std::array<ResultType, size() / sizeof(ResultType)> *buffer);
\end{cppcode}
The operators are not restricted to increment the counter only once for each
random buffer. The only restriction is that \verb|size()| is divisible by
\verb|sizeof(ResultType)|. This rule is enforced at compile-time. In the
remaining of this section, we introduce a few generators implemented by the
library. A few configuration macros of these \rng{}s are listed in
table~\ref{tab:Configuration macros for counter-based RNGs}.

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Macro & Default \\
    \midrule
    \verb|VSMC_RNG_AES128_ROUNDS|          & \verb|10| \\
    \verb|VSMC_RNG_AES192_ROUNDS|          & \verb|12| \\
    \verb|VSMC_RNG_AES256_ROUNDS|          & \verb|14| \\
    \verb|VSMC_RNG_ARS_ROUNDS|             & \verb|5|  \\
    \verb|VSMC_RNG_AES_NI_BLOCKS|          & \verb|8|  \\
    \verb|VSMC_RNG_PHILOX_ROUNDS|          & \verb|10| \\
    \verb|VSMC_RNG_PHILOX_VECTOR_LENGTH|   & \verb|4|  \\
    \verb|VSMC_RNG_THREEFRY_ROUNDS|        & \verb|20| \\
    \verb|VSMC_RNG_THREEFRY_VECTOR_LENGTH| & \verb|4|  \\
    \verb|VSMC_RNG_RDRAND_NTRIAL_MAX|      & \verb|0|  \\
    \bottomrule
  \end{tabularx}
  \caption{Configuration macros for counter-based \rng{}s}
  \label{tab:Configuration macros for counter-based RNGs}
\end{table}

\subsection{\protect\aesni instructions based \protect\rng}
\label{sub:AES-NI instructions based RNG}

The \aesni instructions based \rng{}s in \textcite{Salmon:2011um} are
implemented in a more general form,
\begin{cppcode}
  template <typename KeySeqType, std::size_t Rounds, std::size_t Blocks>
  class AESNIGenerator;

  template <typename ResultType, typename KeySeqType, std::size_t Rounds,
      std::size_t Blocks>
  using AESNIEngine =
      CounterEngine<ResultType, AESNIGenerator<KeySeqType, Rounds, Blocks>>;
\end{cppcode}
where \verb|KeySeqType| is the class used to generate the sequence of round
keys; \verb|Rounds| is the number of rounds of \aes encryption to be performed.
See the reference manual for details of how to define the key sequence class.
The \aesni encryption instructions have a latency of seven or eight cycles,
while they can be issued at every cycle. Therefore better performance can be
achieved if multiple 128-bits random integers are generated at the same time.
This is specified by the template parameter \verb|Blocks|. Larger blocks, up to
eight, might improve performance but this is at the cost of larger state size.
Without going into details, there are four types of sequence of round keys
implemented by this library,
\begin{cppcode}
  template <std::size_t Rounds>
  using AES128KeySeq =
      internal::AESKeySeq<Rounds, internal::AES128KeySeqGenerator>;
  
  template <std::size_t Rounds>
  using AES192KeySeq =
      internal::AESKeySeq<Rounds, internal::AES192KeySeqGenerator>;
  
  template <std::size_t Rounds>
  using AES256KeySeq =
      internal::AESKeySeq<Rounds, internal::AES256KeySeqGenerator>;
  
  template <typename Constants = ARSConstants>
  using ARSKeySeq = internal::ARSKeySeqImpl<Constants>;
\end{cppcode}
and correspondingly four \rng engines,
\begin{cppcode}
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_AES128_ROUNDS,
      std::size_t Blocks = VSMC_RNG_AES_NI_BLOCKS>
  using AES128Engine =
      AESNIEngine<ResultType, AES128KeySeq<Rounds>, Rounds, Blocks>;
  
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_AES192_ROUNDS,
      std::size_t Blocks = VSMC_RNG_AES_NI_BLOCKS>
  using AES192Engine =
      AESNIEngine<ResultType, AES192KeySeq<Rounds>, Rounds, Blocks>;
  
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_AES256_ROUNDS,
      std::size_t Blocks = VSMC_RNG_AES_NI_BLOCKS>
  using AES256Engine =
      AESNIEngine<ResultType, AES256KeySeq<Rounds>, Rounds, Blocks>;
  
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_ARS_ROUNDS,
      std::size_t Blocks = VSMC_RNG_AES_NI_BLOCKS,
      typename Constants = ARSConstants>
  using ARSEngine =
      AESNIEngine<ResultType, ARSKeySeq<Constants>, Rounds, Blocks>;
\end{cppcode}
The first three are equivalent to \aes-128, \aes-192 and \aes-256 block ciphers
used in counter mode. The last is the \ars algorithm introduced by
\textcite{Salmon:2011um}. The last template parameter \verb|Constants| of
\verb|ARSKeySeq| and \verb|ARSEngine| is a trait class that defines the
constants of the Weyl's sequence. See \textcite{Salmon:2011um} for details. The
defaults are taken from the paper. To use an alternative pair of 64-bits
integers for the constants, one can define and use a trait class as the
following,
\begin{cppcode}
  template <std::size_t>
  struct NewWeylConstant;

  template<>
  struct NewWeylConstant<0>
  {
      static constexpr std::uint64_t value = FIRST_CONSTANT;
  };

  template<>
  struct NewWeylConstant<1>
  {
      static constexpr std::uint64_t value = SECOND_CONSTANT;
  };

  struct NewConstants
  {
      template <std::size_t I>
      using weyl = NewWeylConstant<I>;
  };

  using NewARS = ARSEngine<ResultType, Rounds, NewConstants>;
\end{cppcode}
Alternative methods are also possible. The only requirement is that, the
following expression,
\begin{cppcode}
  template <std::size_t I>
  using weyl = typename Constants::template weyl<I>;
\end{cppcode}
shall define a type that has a static constant expression member data
\verb|value| that is the \verb|I|\ith Weyl constant.

A few type aliases are defined for convenience. For example,
\begin{cppcode}
  using ARSx8    = ARSEngine<std::uint32_t, VSMC_RNG_ARS_ROUNDS, 8>;
  using ARSx8_64 = ARSEngine<std::uint64_t, VSMC_RNG_ARS_ROUNDS, 8>;
  using ARS      = ARSEngine<std::uint32_t>;
  using ARS_64   = ARSEngine<std::uint64_t>;
\end{cppcode}
The engine \verb|ARS| is the library's default \rng if \aesni instructions as
supported. Aliases for block sizes 1, 2, 4 and 8 are defined for all four
algorithms, as well as both 32- and 64-bits versions. These aliases are listed
in table~\ref{tab:Counter-based RNG}.

The performance of these engines depends on a few factors, such as \cpu types,
compilers, operating systems, etc. For example, the theoretical peak
performance for \verb|ARSx8| is 0.32 cycles per byte (cpB) on recent \cpu{}s.
In realistic situations, depending on the compiler, on the same computer values
ranging from 0.44 to 1.2 cpB were observed by the author. In any case, such
performance is good enough even for the most demanding applications. The
library does not attempt to optimize the algorithm for any particular platform.
In realistic applications, the performance of \rng is unlikely to become a
bottle neck. Note that, the best performance is obtained with the vectorized
\verb|rng_rand| function (see section~\ref{sec:Vectorized random number
  generating}). If the \rng{} is used to generate random integer one at a time,
the performance is about a half of the vectorized operation.

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename T, std::size_t K = VSMC_RNG_PHILOX_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_PHILOX_ROUNDS,
      typename Constants = PhiloxConstants<T, K>>
  class PhiloxGenerator;

  template <typename ResultType, typename T = ResultType,
      std::size_t K = VSMC_RNG_PHILOX_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_PHILOX_ROUNDS,
      typename Constants = PhiloxConstants<T, K>>
  using PhiloxEngine =
      CounterEngine<ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;

  template <typename ResultType>
  using Philox2x32Engine = PhiloxEngine<ResultType, std::uint32_t, 2>;

  template <typename ResultType>
  using Philox4x32Engine = PhiloxEngine<ResultType, std::uint32_t, 4>;

  template <typename ResultType>
  using Philox2x64Engine = PhiloxEngine<ResultType, std::uint64_t, 2>;

  template <typename ResultType>
  using Philox4x64Engine = PhiloxEngine<ResultType, std::uint64_t, 4>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Type aliases are also defined, as listed in
table~\ref{tab:Counter-based RNG}. The template parameter \verb|Counstants| is
similar to that of \verb|ARSEngine|. It defines the round constants of the
algorithm. The defaults are taken from the paper. See the reference manual for
details.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename T, std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS,
      typename Constants = ThreefryConstants<T, K>>
  class ThreefryGenerator;

  template <typename ResultType, typename T = ResultType,
      std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS,
      typename Constants = ThreefryConstants<T, K>>
  using ThreefryEngine =
      CounterEngine<ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;

  template <typename ResultType>
  using Threefry2x32Engine = ThreefryEngine<ResultType, std::uint32_t, 2>;

  template <typename ResultType>
  using Threefry4x32Engine = ThreefryEngine<ResultType, std::uint32_t, 4>;

  template <typename ResultType>
  using Threefry2x64Engine = ThreefryEngine<ResultType, std::uint64_t, 2>;

  template <typename ResultType>
  using Threefry4x64Engine = ThreefryEngine<ResultType, std::uint64_t, 4>;

  template <typename ResultType>
  using Threefry8x64Engine = ThreefryEngine<ResultType, std::uint64_t, 8>;

  template <typename ResultType>
  using Threefry16x64Engine = ThreefryEngine<ResultType, std::uint64_t, 16>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Type aliases are also defined, as listed in
table~\ref{tab:Counter-based RNG}. The template parameter \verb|Counstants| is
similar to that of \verb|ARSEngine|. It defines the round constants of the
algorithm. The defaults are taken from the paper. See the reference manual for
details.

\subsection{Default \protect\rng}
\label{sub:Default RNG}

Note that, not all \rng{}s defined by the library is available on all
platforms. The library also defines a type alias \verb|RNG| which is one of the
\rng{}s listed in table~\ref{tab:Counter-based RNG}. The preference is in the
order listed in table~\ref{tab:Default RNG}. The user can define the
configuration macro \verb|VSMC_RNG_TYPE| to override the choice made by the
library.

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Class & Availability \\
    \midrule
    \verb|ARS|      & \verb|VSMC_HAS_AES_NI| \\
    \verb|Threefry| & Always available       \\
    \bottomrule
  \end{tabularx}
  \caption{Default RNG}
  \label{tab:Default RNG}
\end{table}

\section{Non-deterministic RNG}
\label{sec:Non-deterministic RNG}

If the \rdrand instructions are supported, the library also implements three
\rng{}s, \verb|RDRAND16|, \verb|RDRAND32| and \verb|RDRAND64|. They output 16-,
32-, and 64-bits random integers, respectively. The \rdrand instruction may not
return a random integers at all. The engines will keep trying until it
succeeds. One can limit the maximum number of trials by define the
configuration macro \verb|VSMC_RNG_RDRAND_NTRIAL_MAX|. A value of zero, the
default, means the number of trials is unlimited. If it is a positive number,
and if after the specified number of trials no random integer is return by the
\rdrand instruction, zero is returned.

\section{MKL RNG}
\label{sec:MKL RNG}

The \mkl library provides some high performance \rng{}s. The library implements
a wrapper class \verb|MKLEngine| that makes them accessible as \cppoo{}
generators. They are listed in table~\ref{tab:MKL RNG}. Note that, \mkl{}
\rng{}s performs best when they are used to generate vectors of random numbers.
These wrappers use a buffer to store such vectors. And thus they have much
larger state space than usual \rng{}s. Each \rng engines output by default
32-bits integers. Similar to the counter-based \rng{}s, 64-bits variants are
also defined.

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Class & \mkl \brng \\
    \midrule
    \verb|MKL_MCG59|         & \verb|VSL_BRNG_MCG59|         \\
    \verb|MKL_MT19937|       & \verb|VSL_BRNG_MT19937|       \\
    \verb|MKL_MT2203|        & \verb|VSL_BRNG_MT2203|        \\
    \verb|MKL_SFMT19937|     & \verb|VSL_BRNG_SFMT19937|     \\
    \verb|MKL_NONDETERM|     & \verb|VSL_BRNG_NONDETERM|     \\
    \verb|MKL_ARS5|          & \verb|VSL_BRNG_ARS5|          \\
    \verb|MKL_PHILOX4X32X10| & \verb|VSL_BRNG_PHILOX4X32X10| \\
    \bottomrule
  \end{tabularx}
  \caption{\mkl{} \rng; Each \rng engine may have suffix \texttt{\_64}}
  \label{tab:MKL RNG}
\end{table}

\section{Multiple RNG streams}
\label{sec:Multiple RNG streams}

Earlier in section~\ref{sub:Particle} we introduced that \verb|particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called \verb|RNGSet|. Three of them are implemented in the library.
They all have the same interface,
\begin{cppcode}
  RNGSet<RNG> rng_set(N); // A set of N RNGs
  rng_set.resize(n);      // Change the size of the set
  rng_set.seed();         // Seed each RNG in the set with Seed::instance()
  rng_set[i];             // Get a reference to the i-th RNG
\end{cppcode}
The first implementation is \verb|RNGSetScalar|. As its name suggests, it is
only a wrapper of a single \rng. All calls to \verb|rng_set[i]| returns a
reference to the same \rng. It is only useful when an \verb|RNGSet| interface
is required while the thread-safety and other issues are not important.

The second implementation is \verb|RNGSetVector|. It is an array of \rng{}s
with length $N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s
have small state size and thus for moderate $N$, this cost is not an issue. The
method calls \verb|rng_set[i]| and \verb|rng_set[j]| return independent \rng{}s
if $i \ne j$.

Last, if \tbb is available, there is a third implementation \verb|RNGSetTBB|,
which uses thread-local storage (\tls). It has much smaller memory footprint
than \verb|RNGSetVector| while maintains better thread-safety. The performance
impact of using \tls is minimal unless the computation at the calling site is
trivial. For example,
\begin{cppcode}
  std::size_t eval_pre(SingleParticle<T> sp)
  {
      auto &rng = sp.rng();
      // using rng to initialize state
      // do some computation, likely far more costly than TLS
  }
\end{cppcode}
The type alias \verb|RNGSet| is defined to be \verb|RNGSetTBB| if \tbb is
available, otherwise defined to be \verb|RNGSetVector|. It is used by the
\verb|Particle| class template. One can replace the type of \rng set used by
\verb|Particle<T>| with a member type of \verb|T|. For example,
\begin{cppcode}
  class T
  {
      using rng_set_type = RNGSetScalar<RNG>;
  };
\end{cppcode}
will replace the type of the \rng set contained in \verb|Particle<T>|. Note
that, \verb|Particle<T>| itself does not use any \rng in the set.

\section{Distributions}
\label{sec:Distributions}

The library also provides implementations of some common distributions. They
all conforms to the \cppoo random number distribution concepts. Some of them
are the same as those in the \cppoo standard library, with \verb|CamelCase|
names. For example, \verb|NormalDistribuiton| can be used as a drop-in
replacement of \verb|std::normal_distribuiton|. This includes all of the
continuous distributions defined in the standard library.
Table~\ref{tab:Random number distributions} lists all the additional
distributions implemented. As stated in section~\ref{sec:Vectorized random
  number generating}, they support vectorized random number generating. In the
following sections we introduce each distributions included in the library.

\begin{table}
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    Class & Notes \\
    \midrule
    \verb|LaplaceDistribution|
    & Parameters: location \verb|a|; scale \verb|b| \\
    \verb|LevyDistribution|
    & Parameters: location \verb|a|; scale \verb|b| \\
    \verb|ParetoDistribution|
    & Parameters: shape \verb|a|; scale \verb|b| \\
    \verb|RayleighDistribution|
    & Parameters: scale \verb|sigma| \\
    \bottomrule
  \end{tabularx}
  \caption{Random number distributions}
  \label{tab:Random number distributions}
\end{table}

\subsection{Uniform distributions}
\label{sub:Uniform distributions}

\subsection{Normal and related distribution} 
\label{sub:Normal and related distribuiton} 

\subsection{Gamma and related distribution}
\label{sub:Gamma and related distribution}

\subsection{Beta distribution}
\label{sub:Beta distribution}

\subsection{Distributions using inverse method}
\label{sub:Distributions using inverse method}

\section{Seeding}
\label{sec:Seeding}

The singleton class template \verb|SeedGenerator| can be used to generate
distinctive seed sequentially. For example,
\begin{cppcode}
  auto &seed = SeedGenerator<void, unsigned>::instance();
  RNG rng1(seed.get()); // Construct rng1
  RNG rng2(seed.get()); // Construct rng2 with another seed
\end{cppcode}
The first argument to the template can be any type. For different types,
different instances of \verb|SeedGenerator| will be created. Thus, the seeds
generated by \verb|SeedGenerator<T1>| and \verb|SeedGenerator<T2>| will be
independent. The second parameter is the type of the seed values. It can be an
unsigned integer type. Classes such as \verb|Particle<T>| will use the
generator of the following type,
\begin{cppcode}
  using Seed = SeedGenerator<NullType, VSMC_SEED_RESULT_TYPE>;
\end{cppcode}
where \verb|VSMC_SEED_RESULT_TYPE| is a configuration macro which is defined to
\verb|unsigned| by default.

One can save and set the seed generator using standard \cpp streams. For
example
\begin{cppcode}
  std::ifstream seed_txt("seed.txt");
  if (seed_txt.good())
      seed_txt >> Seed::instance(); // Read seed from a file
  else
      Seed::instance().set(101);    // The default seed
  seed_txt.close();
  // The program
  std::ofstream seed_txt("seed.txt");
  seed_txt << Seed::instance();     // Write the seed to a file
  seed_txt.close();
\end{cppcode}
This way, if the simulation program need to be repeated multiple times, each
time is will use a different set of seeds.

A single seed generator is enough for a single computer program. However, it is
more difficult to ensure that each computing node has a distinctive set of
seeds in a distributed system. A simple solution is to use the \verb|modulo|
method of \verb|SeedGenerator|. For example,
\begin{cppcode}
  Seed::instance().modulo(n, r);
\end{cppcode}
where $n$ is the number of processes and $r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r\mod{n}$. Therefore, no two nodes will ever generate the same seeds.
