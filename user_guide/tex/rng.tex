\chapter{Random number generating}
\label{chap:Random number generating}

The library has a comprehensive \rng system to facilitate implementation of
Monte Carlo algorithms.

\section{Seeding}
\label{sec:Seeding}

The singleton class template \verb|SeedGenerator| can be used to generate
distinctive seed sequentially. For example,
\begin{cppcode}
  auto &seed = SeedGenerator<void, unsigned>::instance();
  RNG rng1(seed.get()); // Construct rng1
  RNG rng2(seed.get()); // Construct rng2 with another seed
\end{cppcode}
The first argument to the template can be any type. For different types,
different instances of \verb|SeedGenerator| will be created. Thus, the seeds
generated by \verb|SeedGenerator<T1>| and \verb|SeedGenerator<T2>| will be
independent. The second parameter is the type of the seed values. It can be an
unsigned integer type. Classes such as \verb|Particle<T>| will use the
generator of the following type,
\begin{cppcode}
  using Seed = SeedGenerator<NullType, VSMC_SEED_RESULT_TYPE>;
\end{cppcode}
where \verb|VSMC_SEED_RESULT_TYPE| is a configuration macro which is defined to
\verb|unsigned| by default.

One can save and set the seed generator using standard \cpp streams. For
example
\begin{cppcode}
  std::ifstream seed_txt("seed.txt");
  if (seed_txt.good())
      seed_txt >> Seed::instance(); // Read seed from a file
  else
      Seed::instance().set(101);    // The default seed
  seed_txt.close();
  // The program
  std::ofstream seed_txt("seed.txt");
  seed_txt << Seed::instance();     // Write the seed to a file
  seed_txt.close();
\end{cppcode}
This way, if the simulation program need to be repeated multiple times, each
time is will use a different set of seeds.

A single seed generator is enough for a single computer program. However, it is
more difficult to ensure that each computing node has a distinctive set of
seeds in a distributed system. A simple solution is to use the \verb|modulo|
method of \verb|SeedGenerator|. For example,
\begin{cppcode}
  Seed::instance().modulo(n, r);
\end{cppcode}
where $n$ is the number of processes and $r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r\mod{n}$. Therefore, no two nodes will ever generate the same seeds.

\section{Counter-based \protect\rng}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng classes. Unfortunately, none of
them are suitable for parallel computing without considerable efforts.

The development by \textcite{Salmon:2011um} made high performance parallel \rng
much more accessible than it was before. In the author's personal opinion, it
is the most significant development for parallel Monte Carlo algorithms in
recent memory. See the paper for more details. Here, it is sufficient to
note that, the \rng{}s introduced in the paper use deterministic functions
$f_k$, such that, for any sequence $\{c_i\}_{i>0}$, the sequence
$\{y_i\}_{i>0}$, $y_i = f_k(c_i)$, appears as random. In addition, for $k_1 \ne
k_2$, $f_{k_1}$ and $f_{k_2}$ will generate two sequences that appear
statistically independent. Compared to more conventional \rng{}s which use
recursions $y_i = f(y_{i - 1})$, these counter-based \rng{}s are much easier to
setup in a parallelized environment.

If $c$, the counter, is an unsigned integer with $b$ bits, and $k$, the key, is
an unsigned integer with $d$ bits. Then for each $k$, the \rng has a period
$2^b$. And there can be at most $2^d$ independent streams.
Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in this library, along with the bits of the counter and the key. They all
conform to the \cppoo uniform \rng concept. All \rng{}s in
\textcite{Salmon:2011um} are implemented along with a few additions. Note that,
the actual period of an \rng can be longer. For example, \verb|Philox4x64| has
a 256-bit counter but output 64-bit integers. And thus it has a $2^{1024}$
period. Such period length may seem very small compared to many well known
\rng{}s. For example, the famous Mersenne-Twister generator
(\verb|std::mt19937|) has a period $2^{19937} - 1$. However, combined with
$2^{256}$ independent streams, only the most demanding programs will find these
counter-base \rng{}s insufficient.

\begin{table}
  \def\B{\textcolor{MRed}{\textit{B}}}
  \def\V{\textcolor{MRed}{\textit{V}}}
  \begin{tabularx}{\textwidth}{XXll}
    \toprule
    & & \multicolumn{2}{c}{Bits} \\
    \cmidrule{3-4}
    Class & Result type & Counter & Key \\
    \midrule
    \texttt{AES128\_\B x32} & \verb|std::uint32_t| & $128$ & $128$ \\
    \texttt{AES128\_\B x64} & \verb|std::uint64_t| & $128$ & $128$ \\
    \texttt{AES192\_\B x32} & \verb|std::uint32_t| & $128$ & $192$ \\
    \texttt{AES192\_\B x64} & \verb|std::uint64_t| & $128$ & $192$ \\
    \texttt{AES256\_\B x32} & \verb|std::uint32_t| & $128$ & $256$ \\
    \texttt{AES256\_\B x64} & \verb|std::uint64_t| & $128$ & $256$ \\
    \texttt{ARS\_\B x32}    & \verb|std::uint32_t| & $128$ & $128$ \\
    \texttt{ARS\_\B x64}    & \verb|std::uint64_t| & $128$ & $128$ \\
    \texttt{Philox2x32}     & \verb|std::uint32_t| & $64$  & $64$  \\
    \texttt{Philox2x64}     & \verb|std::uint64_t| & $128$ & $128$ \\
    \texttt{Philox4x32}     & \verb|std::uint32_t| & $128$ & $128$ \\
    \texttt{Philox4x64}     & \verb|std::uint64_t| & $256$ & $256$ \\
    \texttt{Threefry2x32}   & \verb|std::uint32_t| & $64$  & $64$  \\
    \texttt{Threefry2x64}   & \verb|std::uint64_t| & $128$ & $128$ \\
    \texttt{Threefry4x32}   & \verb|std::uint32_t| & $128$ & $128$ \\
    \texttt{Threefry4x64}   & \verb|std::uint64_t| & $256$ & $256$ \\
    \bottomrule
  \end{tabularx}
  \caption{Counter-based \rng; \B: either \texttt{1}, \texttt{2}, \texttt{4},
    or \texttt{8}.}
  \label{tab:Counter-based RNG}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Macro & Default \\
    \midrule
    \verb|VSMC_RNG_AES_BLOCKS|             & \verb|4|  \\
    \verb|VSMC_RNG_ARS_ROUNDS|             & \verb|5|  \\
    \verb|VSMC_RNG_ARS_BLOCKS|             & \verb|4|  \\
    \verb|VSMC_RNG_PHILOX_ROUNDS|          & \verb|10| \\
    \verb|VSMC_RNG_PHILOX_VECTOR_LENGTH|   & \verb|4|  \\
    \verb|VSMC_RNG_THREEFRY_ROUNDS|        & \verb|20| \\
    \verb|VSMC_RNG_THREEFRY_VECTOR_LENGTH| & \verb|4|  \\
    \bottomrule
  \end{tabularx}
  \caption{Configuration macros for counter-based \rng{}s}
  \label{tab:Configuration macros for counter-based RNGs}
\end{table}

\subsection{\protect\aesni intrinsics based \protect\rng}
\label{sub:AES-NI intrinsics based RNG}

The \aesni intrinsics based \rng{}s in \textcite{Salmon:2011um} are implemented
in a more general form,
\begin{cppcode}
  template <typename ResultType, typename KeySeqType, std::size_t Rounds,
      std::size_t Blocks>
  using AESNIEngine =
      CounterEngine<AESNIGenerator<ResultType, KeySeqType, Rounds, Blocks>>;
\end{cppcode}
where \verb|KeySeqType| is the class used to generate the sequence of round
keys; \verb|Rounds| is the number of rounds of \aes encryption to be performed.
See the reference manual for details of how to define the key sequence class.
The \aesni instructions have a latency of seven or eight cycles, while they can
be issued at every cycle. Therefore better performance can be achieved if
multiple 128-bit random integers are generated at the same time. This is
specified by the template parameter \verb|Blocks|. Larger blocks, up to eight,
can improve runtime performance but this is at the cost of larger state size.

Four types of key sequences are implemented by the library, corresponding to
the \ars algorithm in \textcite{Salmon:2011um} and the \aes-128, \aes-192, and
\aes-256 algorithms. The following \rng engines are defined.
\begin{cppcode}
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_ARS_ROUNDS,
      std::size_t Blocks = VSMC_RNG_ARS_BLOCKS>
  using ARSEngine =
      AESNIEngine<ResultType, ARSKeySeq<ResultType>, Rounds, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES128Engine =
      AESNIEngine<ResultType, AES128KeySeq<ResultType, 10>, 10, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES192Engine =
      AESNIEngine<ResultType, AES192KeySeq<ResultType, 12>, 12, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES256Engine =
      AESNIEngine<ResultType, AES256KeySeq<ResultType, 14>, 14, Blocks>;
\end{cppcode}
The default template arguments can be changed by configuration macros listed in
table~\ref{tab:Configuration macros for counter-based RNGs}. Type aliases are
also defined, as listed in table~\ref{tab:Counter-based RNG}. For example,
\verb|ARS_4x32| is \verb|ARSEngine| with result type \verb|std::uint32_t|, four
blocks, and the default number of rounds.

The type aliases \verb|ARS|, \verb|AES128|, \verb|AES192| and \verb|AES256| are
the respective engines with \verb|std::uint32_t| as \verb|ResultType| and other
template parameters taking their default values. Similarly, \verb|ARS_64|,
\verb|AES128_64|, \verb|AES192_64| and \verb|AES256_64| are type aliases with
\verb|std::uint64_t| as \verb|ResultType|.

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename ResultType, std::size_t K = VSMC_RNG_PHILOX_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_PHILOX_ROUNDS>
  using PhiloxEngine = CounterEngine<PhiloxGenerator<ResultType, K, Rounds>>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Type aliases are also defined, as listed in
table~\ref{tab:Counter-based RNG}. For example, \verb|Philox4x32| is
\verb|PhiloxEngine| with result type \verb|std::uint32_t|, vector length four,
and the default number of rounds. The type aliases \verb|Philox| and
\verb|Philox_64| are defined similarly to \verb|ARS| and \verb|ARS_64|,
respectively.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename ResultType, std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS>
  using ThreefryEngine = CounterEngine<ThreefryGenerator<ResultType, K, Rounds>>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Type aliases are also defined, as listed in
table~\ref{tab:Counter-based RNG}. For example, \verb|Threefry4x32| is
\verb|ThreefryEngine| with result type \verb|std::uint32_t|, vector length
four, and the default number of rounds. The type aliases \verb|Threefry| and
\verb|Threefry_64| are defined similarly to \verb|ARS| and \verb|ARS_64|,
respectively.

\subsection{Default \protect\rng}
\label{sub:Default RNG}

Note that, not all \rng{}s defined by the library is available on all
platforms. The library also defines a type alias \verb|RNG| which is one of the
\rng{}s listed in table~\ref{tab:Counter-based RNG}. The preference is in the
order listed in table~\ref{tab:Default RNG}. The user can define the
configuration macro \verb|VSMC_RNG_TYPE| to override the choice made by the
library.

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Class & Availability \\
    \midrule
    \verb|ARS|    & \verb|VSMC_HAS_AES_NI| \\
    \verb|Philox| & Always available       \\
    \bottomrule
  \end{tabularx}
  \caption{Default RNG}
  \label{tab:Default RNG}
\end{table}

\section{Non-deterministic \protect\rng}
\label{sec:Non-deterministic RNG}

If the \rdrand intrinsics are supported, the library also implements three
\rng{}s, \verb|RDRAND16|, \verb|RDRAND32| and \verb|RDRAND64|. They output 16-,
32-, and 64-bit random unsigned integers, respectively.

\section{\protect\mkl{} \protect\rng}
\label{sec:MKL RNG}

The \mkl library provides some high performance \rng{}s. The library implements
a wrapper class \verb|MKLEngine| that makes them accessible as \cppoo{}
generators. They are listed in table~\ref{tab:MKL RNG}. Note that, \mkl{}
\rng{}s performs best when they are used to generate vectors of random numbers.
These wrappers use a buffer to store such vectors. And thus they have much
larger state space than usual \rng{}s.

\begin{table}
  \begin{tabularx}{\textwidth}{XXX}
    \toprule
    Class & Result type & \mkl \brng \\
    \midrule
    \verb|MKL_MCG59|
    & \verb|unsigned|           & \verb|VSL_BRNG_MCG59|         \\
    \verb|MKL_MCG59_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_MCG59|         \\
    \verb|MKL_MT19937|
    & \verb|unsigned|           & \verb|VSL_BRNG_MT19937|       \\
    \verb|MKL_MT19937_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_MT19937|       \\
    \verb|MKL_MT2203|
    & \verb|unsigned|           & \verb|VSL_BRNG_MT2203|        \\
    \verb|MKL_MT2203_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_MT2203|        \\
    \verb|MKL_SFMT19937|
    & \verb|unsigned|           & \verb|VSL_BRNG_SFMT19937|     \\
    \verb|MKL_SFMT19937_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_SFMT19937|     \\
    \verb|MKL_NONDETERM|
    & \verb|unsigned|           & \verb|VSL_BRNG_NONDETERM|     \\
    \verb|MKL_NONDETERM_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_NONDETERM|     \\
    \verb|MKL_ARS5|
    & \verb|unsigned|           & \verb|VSL_BRNG_ARS5|          \\
    \verb|MKL_ARS5_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_ARS5|          \\
    \verb|MKL_PHILOX4X32X10|
    & \verb|unsigned|           & \verb|VSL_BRNG_PHILOX4X32X10| \\
    \verb|MKL_PHILOX4X32X10_64|
    & \verb|unsigned MKL_INT64| & \verb|VSL_BRNG_PHILOX4X32X10| \\
    \bottomrule
  \end{tabularx}
  \caption{\mkl{} \rng}
  \label{tab:MKL RNG}
\end{table}

\section{Multiple \protect\rng streams}
\label{sec:Multiple RNG streams}

Earlier in section~\ref{sub:Particle} we introduced that \verb|particle.rng(i)|
returns an independent \rng instance. This is actually done through a class
template called \verb|RNGSet|. Three of them are implemented in the library.
They all have the same interface,
\begin{cppcode}
  RNGSet<RNG> rng_set(N); // A set of N RNGs
  rng_set.resize(n);      // Change the size of the set
  rng_set.seed();         // Seed each RNG in the set with Seed::instance()
  rng_set[i];             // Get a reference to the i-th RNG
\end{cppcode}
The first implementation is \verb|RNGSetScalar|. As its name suggests, it is
only a wrapper of a single \rng. All calls to \verb|rng_set[i]| returns a
reference to the same \rng. It is only useful when an \verb|RNGSet| interface
is required while the thread-safety and other issues are not important.

The second implementation is \verb|RNGSetVector|. It is an array of \rng{}s
with length $N$. It has memory cost $O(N)$. Many of the counter-based \rng{}s
have small state size and thus for moderate $N$, this cost is not an issue. The
method calls \verb|rng_set[i]| and \verb|rng_set[j]| return independent \rng{}s
if $i \ne j$.

Last, if \tbb is available, there is a third implementation \verb|RNGSetTBB|,
which uses thread-local storage (\tls). It has much smaller memory footprint
than \verb|RNGSetVector| while maintains better thread-safety. The performance
impact of using \tls is minimal unless the computation at the calling site is
trivial. For example,
\begin{cppcode}
  std::size_t eval_pre(SingleParticle<T> sp)
  {
      auto &rng = sp.rng();
      // using rng to initialize state
      // do some computation, likely far more costly than TLS
  }
\end{cppcode}
The type alias \verb|RNGSet| is defined to be \verb|RNGSetTBB| if \tbb is
available, otherwise defined to be \verb|RNGSetVector|. It is used by the
\verb|Particle| class template. One can replace the type of \rng set used by
\verb|Particle<T>| with a member type of \verb|T|. For example,
\begin{cppcode}
  class T
  {
      using rng_set_type = RNGSetScalar<RNG>;
  };
\end{cppcode}
will replace the type of the \rng set contained in \verb|Particle<T>|.  Note
that, \verb|Particle<T>| itself does not use any \rng in the set.

\section{Distributions}
\label{sec:Distributions}

The library also provides implementations of some common distributions. They
all conforms to the \cppoo random number distribution concepts. Some of them
are the same as those in the \cppoo standard library, with \verb|CamelCase|
names. For example, \verb|NormalDistribuiton| can be used as a drop-in
replacement of \verb|std::normal_distribuiton|. This includes all of the
continuous distributions defined in the standard library. Their benefits
compared to the standard library will be discussed later.
Table~\ref{tab:Random number distributions} lists all the additional
distributions implemented. The library also implement the multivariate Normal
distribution. Its usable is shown by the following example,
\begin{cppcode*}{texcomments}
  double mean[2] = { /* the mean vector */ };
  double cov[4] = { /* the covariance matrix */ };
  double chol[3];
  double r[2];
  // Compute the lower triangular of the Cholesky decomposition
  cov_chol(2, cov, chol);
  RNG rng;
  NormalMVDistribution<double, 2> norm2(mean, chol); // Bivariate Normal
  NormalMVDistribution<double, Dynamic> normd(2, mean, chol); // Same as above
  norm2(rng, r); // Generate a bivariate Normal
  normd(rng, r); // Same as above
\end{cppcode*}
We shall mention here that the static form (\verb|norm2|), where the dimension
is specified as a template parameter is more efficient. The distribution accept
the lower triangular of the Choleskey decomposition of the covariance matrix as
input, instead of the covariance matrix itself. The input matrix shall be in
packed format, with row major storage layout. A function \verb|cov_chol| is
provided to compute this decomposition from a covariance matrix stored in
various format. The output is suitable as direct input to the distribution. See
section~\ref{sec:Sample covariance} for details.

\begin{table}
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    Class & Notes \\
    \midrule
    \verb|UniformBits|
    & No parameter, uniform on the set $\{0,\dots,2^b - 1\}$, where $b$ is the
    number of bits of the result type, which has to be an unsigned integer
    type. \\
    \verb|U01|      & No parameter, uniform on $[0, 1)$                 \\
    \verb|U01CC|    & No parameter, uniform on $[0, 1]$                 \\
    \verb|U01CO|    & No parameter, uniform on $[0, 1)$                 \\
    \verb|U01OC|    & No parameter, uniform on $(0, 1]$                 \\
    \verb|U01OO|    & No parameter, uniform on $(0, 1)$                 \\
    \verb|Laplace|  & Parameters: location \texttt{a}; scale \texttt{b} \\
    \verb|Levy|     & Parameters: location \texttt{a}; scale \texttt{b} \\
    \verb|Pareto|   & Parameters: shape \texttt{a}; scale \texttt{b}    \\
    \verb|Rayleigh| & Parameters: scale \texttt{sigma}                  \\
    \bottomrule
  \end{tabularx}
  \caption{Random number distributions. Note: all class names have a suffix
    \texttt{Distribution} which is omitted in the table}
  \label{tab:Random number distributions}
\end{table}

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The \rng{}s and distributions implemented by this library provides vectorized
operations. For example,
\begin{cppcode}
  std::size_t n = 1000;
  RNG rng;
  NormalDistribution<double> norm(0, 1);
  Vector<RNG::result_type> u(n);
  Vector<double> r(n);
  rng(n, u.data());           // Generate n random unsigned integers
  rng_rand(rng, n, u.data()); // Same as above
  norm(rng, n, r.data());     // Generate n Normal random numbers
  normal_distribution(rng, n, r.data(), 0.0, 1.0);     // Same as above
  normal_distribution(rng, n, r.data(), norm.param()); // Same as above
  rng_rand(rng, norm, n, r.data());                    // Same as above
\end{cppcode}
Note that these functions will be specialized to use \mkl routines if
\verb|rng| is one of the engines listed in table~\ref{tab:MKL RNG}.

\section{\protect\rng in C and OpenCL}
\label{sec:RNG in C and OpenCL}

The Philox and Threefry engines, together with a set of functions that transfer
unsigned random integers to floating points numbers, are also implemented with
only a subset of \cnn features. They can be used in both \cnn and OpenCL 1.2
device programs. See appendix~\appref{app:sub:Parallelized implementation using
  OpenCL} for an example of such an OpenCL program. Here we provide a minimal
example that generates two standard Normal random numbers using the Box-Muller
method,
\begin{ccode}
    vsmc_threefry4x32 rng;
    vsmc_threefry4x32_init(&rng, seed);

    uint32_t u32[2];
    u32[0] = vsmc_threefry4x32_rand(&rng);
    u32[1] = vsmc_threefry4x32_rand(&rng);

    double u01[2];
    u01[0] = vsmc_u01_oc_u32d(u32[0]);
    u01[1] = vsmc_u01_oc_u32d(u32[1]);
    u01[0] = sqrt(-2 * log(u01[0]));
    u01[1] *= 2;

    double normal01[2];
    normal01[0] = u01[0] * sin(M_PI * u01[1]);
    normal01[1] = u01[0] * cos(M_PI * u01[1]);
\end{ccode}
For each engine type, there are two primary functions. One is used to
initialize the state. These functions take the form of the engine name suffixed
with \verb|_init|. They take a pointer to the \rng and an unsigned integer as
input. The other function is used to increment the counter and generate
unsigned random integers. These functions take the form of the engine name
suffixed with \verb|_rand|. They take a pointer to the \rng as input and return
an unsigned integer.

The functions that convert unsigned random integers to floating points uniform
on $[0, 1]$ take the form
\texttt{vsmc\_u01\_%
  \textcolor{MRed}{\textit{l}}%
  \textcolor{MRed}{\textit{r}}\_u%
  \textcolor{MRed}{\textit{bits}}%
  \textcolor{MRed}{\textit{fp}}},
where \texttt{\textcolor{MRed}{\textit{l}}} specify the lower bound of the
interval to be closed (\verb|c|) or open (\verb|o|); similarly
\texttt{\textcolor{MRed}{\textit{r}}} specify the upper bound of the interval;
\texttt{\textcolor{MRed}{\textit{bits}}} can be either \verb|32| or \verb|64|,
which specifies the input type to be \verb|uint32_t| or \verb|uint64_t|,
respectively; and last \texttt{\textcolor{MRed}{\textit{fp}}} can be either
\verb|f|, \verb|d|, or \verb|l|, which specifies the output type to be
\verb|float|, \verb|double|, or \verb|long double|, respectively. Note that, if
used in OpenCL device programs, the \verb|long double| versions are not
defined. And the \verb|double| versions are only defined if the macro
\verb|VSMC_HAS_OPENCL_DOUBLE| is defined to a non-zero value.
