\chapter{Utilities}
\label{chap:Utilities}

The library provides some utilities for writing Monte Carlo simulation
programs. For some of them, such as command line option processing, there are
more advanced, dedicated libraries out there. The library only provides some
basic functionality that is sufficient for most simple cases.

\section{Aligned memory allocation}
\label{sec:Aligned memory allocation}

The standard library class \verb|std::allocator| is used by containers to
allocate memory. It works fine in most cases. However, sometime it is desirable
to allocate memory aligned by a certain boundary. The library provides the
class template,
\begin{Verbatim}
  template <typename T, std::size_t Alignment = AlignmentTrait<T>::value,
      typename Memory = AlignedMemory>
  class Allocator;
\end{Verbatim}
which conforms to the \verb|std::allocator| interface. The address of the
pointer returned by the \verb|allocate| method will be a multiple of
\verb|Alignment|. The value of alignment has to be positive, larger than
\verb|sizeof(void *)|, and a power of two. Violating any of these conditions
will result in compile-time error. The last template parameter \verb|Memory|
shall have two static methods,
\begin{Verbatim}
  static void *aligned_malloc(std::size_t n, std::size_t alignment);
  static void aligned_free(void *ptr);
\end{Verbatim}
The method \verb|aligned_malloc| shall behave similar to \verb|std::malloc|
with the additional alignment requirement. It shall return a null pointer if it
fails to allocate memory. In any other case, including zero input size, it
shall return a reachable non-null pointer. The method \verb|aligned_free| shall
behave similar to \verb|std::free|. It shall be able to handle a null pointer
as its input. The library provides a few implementations, listed in
table~\ref{tab:Aligned memory allocation}. In addition, a type alias
\verb|AlignedMemory| is defined to be one of the class listed in the table,
depending on the availability of those classes, with preference in the same
order as they are listed. The user can define the configuration macro
\verb|VSMC_ALIGNED_MEMORY_TYPE| to override the choice made by the library.

The default alignment depends on the type \verb|T|. If it is a scalar type
(\verb|std::is_scalar<T>|), then the alignment is \verb|VSMC_ALIGNMENT|, whose
default is 32. This alignment is sufficient for modern \simd operations, such
as \avx{}2. For other types, the alignment is the maximum of \verb|alignof(T)|
and \verb|VSMC_ALIGNMENT_MIN|, whose default is 16. Two container types are
defined for convenience,
\begin{Verbatim}
  template <typename T>
  using Vector = std::vector<T, Allocator<T>>;

  template <typename T, std::size_t N,
      std::size_t Alignment = AlignmentTrait<T>::value>
  class alignas(Alignment) Array;
\end{Verbatim}

\begin{table}
  \begin{tabularx}{\textwidth}{lXX}
    \toprule
    Class & Implementation & Availability \\
    \midrule
    \verb|AlignedMemoryTBB|
    & \tbb memory allocation functions
    & \verb|VSMC_HAS_TBB_MALLOC|  \\
    \verb|AlignedMemorySYS|
    & Operating system libraries
    & \verb|VSMC_HAS_POSIX|, or using \msvc \\
    \verb|AlignedMemoryMKL|
    & \mkl memory allocation functions
    & \verb|VSMC_HAS_MKL| \\
    \verb|AlignedMemorySTD|
    & Standard library
    & Always available \\
    \bottomrule
  \end{tabularx}
  \caption{Aligned memory allocation}
  \label{tab:Aligned memory allocation}
\end{table}

\section{Sample covariance}
\label{sec:Sample covariance}

The library provides some basic functionality to estimate sample covariance
through the following class template,
\begin{Verbatim}
  template <typename RealType>
  class Covariance;
\end{Verbatim}
At the time of writting, only \verb|float| and \verb|double| are supported.
The class has the following operator as its interface,
\begin{Verbatim}
  void operator()(MatrixLayout layout, std::size_t n, std::size_t p,
      const RealType *x, const RealType *w, RealType *mean,
      RealType *cov, MatrixLayout cov_layout = RowMajor,
      bool cov_upper = false, bool cov_packed = false)
\end{Verbatim}
It computes the sample covariance matrix $\Sigma$,
\begin{align*}
  \Sigma_{i,j} &= \frac{\sum_{i=1}^N w_i}
  {(\sum_{i=1}^N w_i)^2 - \sum_{i=1}^n w_i^2}
  \sum_{k=1}^N w_k (x_{k,i} - \bar{x}_i)(x_{k,j} - \bar{x}_j) \\
  \bar{x}_i &= \frac{1}{\sum_{i=1}^N w_i}\sum_{k=1}^N w_k x_{k,i}
\end{align*}
where $x$ is the $n$ by $p$ matrix of samples, and $w$ is the $n$-vector of
weights. Below we given detailed description of each of the parameters,
\begin{description}
  \item[\texttt{layout}] The storage layout of sample matrix $x$. It is assumed
    to be an $n$ by $p$ matrix.
  \item[\texttt{n}] The number of samples.
  \item[\texttt{p}] The dimension of each sample.
  \item[\texttt{x}] The sample matrix. If it is a null pointer, then no
    computation is carried out.
  \item[\texttt{w}] The weight vector. If it is a null pointer, then all
    samples are assigned weight $1$.
  \item[\texttt{mean}] Output storage of the mean. If it is a null pointer,
    then it is ignored.
  \item[\texttt{cov}] Output storage of the covariance matrix. If it is a null
    pointer, then it is ignored.
  \item[\texttt{cov\_layout}] The storage layout of the covariance matrix.
  \item[\texttt{cov\_upper}] If \verb|true|, then the upper triangular of the
    covariance matrix is packed, otherwise the lower triangular is packed.
    Ignored if \verb|cov_pack| is \verb|false|.
  \item[\texttt{cov\_packed}] If \verb|true|, then the covariance matrix is
    packed.
\end{description}
The last three parameters specify the storage scheme of the covariance matrix.
See any reference of \blas or \lapack for explanation of the scheme. Below is
an example of the class in use,
\begin{Verbatim}
  using T = StateMatrix<RowMajor, p, double>;
  Sampler<T> sampler(n);
  // Iterate the sampler
  double mean[p];
  double cov[p * (p + 1) / 2];
  Covariance eval;
  auto x = sampler.particle().value().data();
  auto w = sampler.particle().weight().data();
  eval(RowMajor, n, p, x, w, mean, cov, RowMajor, false, true);
\end{Verbatim}
One can later compute the Cholesky decomposition using \lapack or other linear
algebra libraries. Below is an example of using the covariance matrix to
generate multivariate Normal proposals,
\begin{Verbatim}
  double chol[p * (p + 1) / 2];
  double y[p];
  LAPACKE_dpptrf(LAPACK_ROW_MAJOR, 'L', p, chol);
  NormalMVDistribution<double, p> normal_mv(nullptr, chol); // zero mean
  normal_mv(rng, y);
\end{Verbatim}

\section{Store objects in \protect\hdf format}
\label{sec:Store objects in HDF5 format}

If the \hdf library is available (\verb|VSMC_HAS_HDF5|), it is possible to
store \verb|Sampler<T>| objects, etc., in the \hdf format. For example,
\begin{Verbatim}
  hdf5store(sampler, "pf.h5", "sampler", false);
\end{Verbatim}
creates a \hdf file named \verb|pf.h5| with the sampler stored as a list in the
group \verb|sampler|. If the last argument is \verb|true|, the data is inserted
to an existing file. Otherwise a new file is created. In R it can be processed
as the following,
\begin{Verbatim}
  library(rhdf5)
  pf <- as.data.frame(h5read("pf.h5", "sampler"))
\end{Verbatim}
This creates a \verb|data.frame| similar to that shown in
section~\ref{sub:Implementations}. The \verb|hdf5store| function is overloaded
for \verb|StateMatrix|, \verb|Sampler<T>| and \verb|Monitor<T>|. It is also
overloaded for \verb|Particle<T>| if an overload for \verb|T| is available.
Such an overload is automatically available if \verb|T| is a derived class of
\verb|StateMatrix|. However, it may not be the most suitable one. Other types
of objects can also be stored, see the reference manual for details.

\section{\protect\raii classes for OpenCL pointers}
\label{sec:RAII classes for OpenCL pointers}

The library provides a few classes to manager OpenCL pointers. It provides
\raii idiom on top of the OpenCL C interface. For example, below is a small
program,
\begin{Verbatim}
  auto platform = cl_get_platform().front();
  auto device = platform.get_device(CL_DEVICE_TYPE_DEFAULT).front();
  CLContext context(CLContextProperties(platform), 1, &device);
  CLCommandQueue command_queue(context, device);
  CLMemory buffer(context, CL_MEM_READ_WRITE, size);
  std::string source = /* read source */;
  CLProgram program(context, 1, &source);
  program.build(1, &device);
  CLKernel kernel(program, "kernel_name");
  kernel.set_arg(0, buffer);
  command_queue.enqueue_nd_range_kernel(kernel, 1, CLNDRange(), CLNDRange(N),
      CLNDRange());
\end{Verbatim}
In the above program, each class type object manages an OpenCL C type, such as
\verb|cl_platform|. The resources will be released when the object is
destroyed. Note that, the copy constructor and assignment operator perform
shallow copy. This is particularly important for \verb|CLMemory| type objects.
In appendix~\appref{app:sub:Parallelized implementation using OpenCL} an OpenCL
implementation of the simple particle filter example in section~\ref{sec:A
  simple particle filter} is shown. Table~\ref{tab:RAII classes for OpenCL
  pointers} lists the classes defined by the library and their corresponding
OpenCL pointers.

\begin{table}
  \begin{tabularx}{\textwidth}{XX}
    \toprule
    Class & OpenCL pointer type \\
    \midrule
    \verb|CLPlatform|     & \verb|cl_platform_id|   \\
    \verb|CLContext|      & \verb|cl_context|       \\
    \verb|CLDevice|       & \verb|cl_device_id|     \\
    \verb|CLCommandQueue| & \verb|cl_command_queue| \\
    \verb|CLMemory|       & \verb|cl_mem|           \\
    \verb|CLProgram|      & \verb|cl_program|       \\
    \verb|CLKernel|       & \verb|cl_kernel|        \\
    \verb|CLEvent|        & \verb|cl_event|         \\
    \bottomrule
  \end{tabularx}
  \caption{\protect\raii classes for OpenCL pointers}
  \label{tab:RAII classes for OpenCL pointers}
\end{table}

\section{Process command line program options}
\label{sec:Process command line program options}

The library provides some basic support for processing command line options.
Here we show a minimal example. The complete program is shown in
appendix~\appref{app:sec:Process command line program options}. First, we
allocate define to store values of options,
\begin{Verbatim}
  int n;
  std::string str;
  std::vector<double> vec;
\end{Verbatim}
All types that support standard library \io stream operations are supported. In
addition, for any type \verb|T| that supports such options,
\verb|std::vector<T, Alloc>|, is also supported. Then,
\begin{Verbatim}
  ProgramOptionMap option_map;
\end{Verbatim}
constructs the container of options. Options can be added to the map,
\begin{Verbatim}
  option_map
      .add("str", "A string option with a default value", &str, "default")
      .add("n", "An integer option", &n)
      .add("vec", "A vector option", &vec);
\end{Verbatim}
The first argument is the name of the option, the second is a description, and
the third is a pointer to where the value of the option shall be stored. The
last optional argument is a default value. The options on the command line can
be processed as the following,
\begin{Verbatim}
  option_map.process(argc, argv);
\end{Verbatim}
where \verb|argc| and \verb|argv| are the arguments of the \verb|main|
function. When the program is invoked, each option can be passed to it like
below,
\begin{Verbatim}
  ./program_option --vec 1 2 1e-1 --str "abc" --vec 8 9 --str "def hij" --n 2 4
\end{Verbatim}
The results of the option processing is displayed below,
\begin{Verbatim}
  n: 4
  str: def hij
  vec: 1 2 0.1 8 9
\end{Verbatim}
To summarize these output, the same option can be specified multiple times. If
it is a scalar option, the last one is used (\verb|--str|, \verb|--n|). The
value of a string option can be grouped by quotes. For a vector option
(\verb|--vec|), all values are gather together and inserted into the vector.

\section{Display program progress}
\label{sec:Display program progress}

Sometime it is desirable to see how much progress of a program has been made.
The library provides a \verb|Progress| class for this purpose. Here we show a
minimal example. The complete program is shown in
appendix~\appref{app:sec:Display program progress}.
\begin{Verbatim}
  Progress progress;
  progress.start(n * n);
  for (std::size_t i = 0; i != n; ++i) {
      std::stringstream ss;
      ss << "i = " << i;
      progress.message(ss.str());
      for (std::size_t j = 0; j != n; ++j) {
          // Do some computation
          progress.increment();
      }
  }
  progress.stop();
\end{Verbatim}
When invoked, the program output something similar the following,
\begin{Verbatim}
  [  4%][00:07][  49019/1000000][i = 49]
\end{Verbatim}
The method \verb|progress.start(n * n)| starts the printing of the progress.
The argument specifies how many iterations there will be before it is stopped.
The method \verb|progress.message(ss.str())| direct the program to print a
message. This is optional. Each time after we finish $n$ iterations (there are
$n^3$ total iterations of the inner-most loop), we increment the progress count
by calling \verb|progress.increment()|. And after everything is finished, the
method \verb|progress.stop()| is called. The \verb|increment| method has an
optional argument, which specifies how many steps has been finished. The
default is one. For example, we can call \verb|progress.start(n * n * n)| and
\verb|progress.increment(n)| instead.

\section{Stop watch}
\label{sec:Stop watch}

Performance can only be improved after it is first properly benchmarked. There
are advanced profiling programs for this purpose. However, sometime simple
timing facilities are enough. The library provides a simple class
\verb|StopWatch| for this purpose. As its name suggests, it works much like a
physical stop watch. Here is a simple example
\begin{Verbatim}
  StopWatch watch;
  for (std::size_t i = 0; i != n; ++i) {
      // Some computation
      watch.start();
      // Computation to be benchmarked;
      watch.stop();
      // Some other computation
  }
  double t = watch.seconds(); // The time in seconds
\end{Verbatim}
The above example demonstrate that timing can be accumulated between loop
iterations, function calls, etc. It shall be noted that, the timing is only
accurate if the computation between \verb|watch.start()| and
\verb|watch.stop()| is non-trivial.
